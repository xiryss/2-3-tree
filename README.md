# 2-3-tree
Я писал реализацию 2-3 дерева в качестве домашней работы в университете. Оно асимптотически оптимально, но все еще медленнее чем std::set.
# Функциональность
Для корректной работы требуется, чтобы для ValueType был определен operator<
Данная реализация поддерживает следующие операции:
1. Инициализация от другого дерева такого же типа, от std::initializer_list, от begin и end произвольного контейнера.
2. Двунаправленные итераторы, то есть it++,++it,--it,it--,(\*it), it->,==,!= а так же .begin(), .end() - итераторы, указывающие на первый элемент дерева, и после последнего.
3. insert(ValueType &x) - вставить элемент x в дерево, если он уже есть, дерево не меняется.
4. erase(ValueType &x) - удалить элемент x из дерева, если его нет, дерево не меняется.
5. find(ValueType &x) - ищет вхождение x в дерево и возвращает итератор, указывающий на это вхождение.
6. lower_bound(ValueType &x) - возвращает итератор, указывающий на первое значение, больше или равное x, или .end(), если такого значения нет.
7. size() - возвращает размер дерева
8. empty() - возвращает, пусто ли дерево
